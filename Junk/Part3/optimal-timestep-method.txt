void NBodySimulation::calculateComprehensiveTimeStep() {
    // This method combines multiple approaches to determine the optimal time step
    // by considering initial conditions, system properties, and numerical stability
    
    // ===== PART 1: PHYSICAL TIMESCALES =====
    
    // Calculate characteristic timescales of the system
    double minOrbitalPeriod = std::numeric_limits<double>::max();
    double totalMass = 0.0;
    double maxDistance = 0.0;
    double minDistance = std::numeric_limits<double>::max();
    double maxVelocity = 0.0;
    double maxAcceleration = 0.0;
    
    // Calculate center of mass
    double comX = 0.0, comY = 0.0, comZ = 0.0;
    for (int i = 0; i < NumberOfBodies; i++) {
        totalMass += mass[i];
        comX += mass[i] * x[i][0];
        comY += mass[i] * x[i][1];
        comZ += mass[i] * x[i][2];
    }
    comX /= totalMass;
    comY /= totalMass;
    comZ /= totalMass;
    
    // Analyze all body pairs for orbital periods and distances
    for (int i = 0; i < NumberOfBodies; i++) {
        // Distance from center of mass (for system size estimate)
        double distFromCOM = sqrt(
            pow(x[i][0] - comX, 2) +
            pow(x[i][1] - comY, 2) +
            pow(x[i][2] - comZ, 2)
        );
        maxDistance = std::max(maxDistance, distFromCOM);
        
        // Current velocity magnitude
        double vel = sqrt(v[i][0]*v[i][0] + v[i][1]*v[i][1] + v[i][2]*v[i][2]);
        maxVelocity = std::max(maxVelocity, vel);
        
        // Calculate max acceleration from all pairwise forces
        for (int j = 0; j < NumberOfBodies; j++) {
            if (i == j) continue;
            
            // Calculate distance between bodies
            double dx = x[j][0] - x[i][0];
            double dy = x[j][1] - x[i][1];
            double dz = x[j][2] - x[i][2];
            double distSquared = dx*dx + dy*dy + dz*dz;
            double dist = sqrt(distSquared);
            
            minDistance = std::min(minDistance, dist);
            
            // For close pairs, calculate orbital period
            if (i < j) {  // avoid double counting
                // Two-body orbital period (Kepler's third law)
                double period = 2.0 * M_PI * sqrt(
                    pow(dist, 3) / (mass[i] + mass[j])
                );
                minOrbitalPeriod = std::min(minOrbitalPeriod, period);
            }
            
            // Calculate acceleration magnitude due to body j
            double acc = mass[j] / (distSquared * dist);
            maxAcceleration = std::max(maxAcceleration, acc);
        }
    }
    
    // ===== PART 2: NUMERICAL STABILITY CRITERIA =====
    
    // Safety factor (more conservative for systems with many bodies)
    double safetyFactor = 0.05 * pow(0.99, std::min(NumberOfBodies / 100, 10)); 
    
    // 1. CFL-like condition: dt < dx/v
    double dtCFL = std::numeric_limits<double>::max();
    if (maxVelocity > 1e-10) {  // Prevent division by zero
        dtCFL = safetyFactor * minDistance / maxVelocity;
    }
    
    // 2. Acceleration-based criterion: dtÂ² < dx/a
    double dtAccel = std::numeric_limits<double>::max();
    if (maxAcceleration > 1e-10) {  // Prevent division by zero
        dtAccel = sqrt(safetyFactor * minDistance / maxAcceleration);
    }
    
    // 3. Orbital resolution criterion: need ~100 steps per orbit
    double dtOrbital = minOrbitalPeriod / 100.0;
    
    // 4. System dynamical time (crossing time)
    double dynTime = sqrt(pow(maxDistance, 3) / totalMass);
    double dtDynamical = dynTime / 100.0;
    
    // 5. Energy conservation - use fewer test steps to avoid memory issues
    double initialEnergy = calculateTotalEnergy();
    double dtEnergy = std::min(dtAccel, dtOrbital);  // Start with a physics-based estimate
    
    // Only test 2-3 carefully chosen timesteps based on the physics criteria
    std::vector<double> testSteps;
    
    // Add the smallest physics-based timestep
    double smallestPhysicsStep = std::min({
        dtAccel, 
        dtOrbital,
        dtDynamical,
        tFinal / 1000.0  // Cap very small steps
    });
    
    // Make sure our test steps are valid
    if (smallestPhysicsStep <= 0 || !std::isfinite(smallestPhysicsStep)) {
        smallestPhysicsStep = tFinal / 1000.0;
    }
    
    // Add only a few carefully chosen test steps
    testSteps.push_back(smallestPhysicsStep);
    testSteps.push_back(smallestPhysicsStep * 2.0);
    
    // For safety with large systems (over 100 bodies), use a simpler approach
    if (NumberOfBodies > 100) {
        // For large systems, we'll skip the energy testing and use physics-based criteria only
        dtEnergy = smallestPhysicsStep;
        std::cout << "Large system detected: Using physics-based time step without energy testing" << std::endl;
    } else {
        // For smaller systems, we can do the full test
        // Save initial state using stack-based storage for small arrays
        std::vector<std::vector<std::vector<double>>> xBackup(NumberOfBodies, 
            std::vector<std::vector<double>>(1, std::vector<double>(3)));
        std::vector<std::vector<std::vector<double>>> vBackup(NumberOfBodies, 
            std::vector<std::vector<double>>(1, std::vector<double>(3)));
        
        // Save current state
        for (int i = 0; i < NumberOfBodies; i++) {
            for (int d = 0; d < 3; d++) {
                xBackup[i][0][d] = x[i][d];
                vBackup[i][0][d] = v[i][d];
            }
        }
        
        double bestError = std::numeric_limits<double>::max();
        
        // Test each timestep
        for (double testStep : testSteps) {
            // Restore initial state
            for (int i = 0; i < NumberOfBodies; i++) {
                for (int d = 0; d < 3; d++) {
                    x[i][d] = xBackup[i][0][d];
                    v[i][d] = vBackup[i][0][d];
                }
            }
            
            // Test this timestep for just a few steps
            double originalT = t;
            timeStepSize = testStep;
            
            // For smaller systems, we can afford more test steps
            int numTestSteps = std::min(5, 1000 / NumberOfBodies);
            for (int step = 0; step < numTestSteps; step++) {
                updateBody();
            }
            
            // Evaluate energy conservation
            double finalEnergy = calculateTotalEnergy();
            double error = std::abs((finalEnergy - initialEnergy) / initialEnergy);
            
            std::cout << "Test dt: " << testStep << " -> Energy error: " << error << std::endl;
            
            if (error < bestError) {
                bestError = error;
                dtEnergy = testStep;
            }
            
            // Reset time
            t = originalT;
        }
        
        // Restore initial state one last time
        for (int i = 0; i < NumberOfBodies; i++) {
            for (int d = 0; d < 3; d++) {
                x[i][d] = xBackup[i][0][d];
                v[i][d] = vBackup[i][0][d];
            }
        }
    }
    
    // ===== PART 3: DETERMINE FINAL TIME STEP =====
    
    // Validate all time steps (replace infinities, NaNs, and zeros with safe values)
    if (!std::isfinite(dtCFL) || dtCFL <= 0) dtCFL = tFinal / 100.0;
    if (!std::isfinite(dtAccel) || dtAccel <= 0) dtAccel = tFinal / 100.0;
    if (!std::isfinite(dtOrbital) || dtOrbital <= 0) dtOrbital = tFinal / 100.0;
    if (!std::isfinite(dtDynamical) || dtDynamical <= 0) dtDynamical = tFinal / 100.0;
    if (!std::isfinite(dtEnergy) || dtEnergy <= 0) dtEnergy = tFinal / 100.0;
    
    // Gather all criteria
    std::vector<std::pair<double, std::string>> criteria = {
        {dtCFL, "CFL condition"},
        {dtAccel, "Acceleration limit"},
        {dtOrbital, "Shortest orbital period / 100"},
        {dtDynamical, "System dynamical time / 100"},
        {dtEnergy, "Empirical energy conservation"}
    };
    
    // Find the limiting criterion (smallest time step)
    double finalTimeStep = tFinal / 10.0;  // Start with a reasonable fraction of total time
    std::string limitingFactor = "Default (tFinal/10)";
    
    for (const auto& criterion : criteria) {
        if (criterion.first > 0 && criterion.first < finalTimeStep) {
            finalTimeStep = criterion.first;
            limitingFactor = criterion.second;
        }
    }
    
    // Additional safety for large systems
    if (NumberOfBodies > 500) {
        double safetyScale = 0.8;  // 20% smaller for large systems
        finalTimeStep *= safetyScale;
        std::cout << "Applied additional " << (1-safetyScale)*100 << "% safety factor for large system" << std::endl;
    }
    
    // Ensure time step isn't too small compared to simulation length
    if (finalTimeStep < tFinal / 1e6) {
        std::cout << "Warning: Calculated time step is extremely small." << std::endl;
        std::cout << "Consider modifying initial conditions or using a specialized integrator." << std::endl;
        finalTimeStep = tFinal / 1e6;  // Cap at a reasonable minimum
    }
    
    // Ensure time step isn't too large compared to total simulation time
    if (finalTimeStep > tFinal / 10.0) {
        finalTimeStep = tFinal / 10.0;
        std::cout << "Warning: Calculated time step is very large. Limiting to tFinal/10." << std::endl;
        limitingFactor = "Maximum limit (tFinal/10)";
    }
    
    // ===== PART 4: OUTPUT RESULTS =====
    
    std::cout << "\n==== COMPREHENSIVE TIME STEP ANALYSIS ====" << std::endl;
    std::cout << "System properties:" << std::endl;
    std::cout << "  * Bodies: " << NumberOfBodies << std::endl;
    std::cout << "  * Total mass: " << totalMass << std::endl;
    std::cout << "  * Max system extent: " << maxDistance << std::endl;
    std::cout << "  * Min separation: " << minDistance << std::endl;
    std::cout << "  * Max velocity: " << maxVelocity << std::endl;
    std::cout << "  * Shortest orbital period: " << minOrbitalPeriod << std::endl;
    std::cout << "  * System dynamical time: " << dynTime << std::endl;
    
    std::cout << "\nTime step criteria:" << std::endl;
    for (const auto& criterion : criteria) {
        std::cout << "  * " << criterion.second << ": " << criterion.first;
        if (criterion.second == limitingFactor) {
            std::cout << " (LIMITING FACTOR)";
        }
        std::cout << std::endl;
    }
    
    std::cout << "\nFinal time step recommendation: " << finalTimeStep << std::endl;
    std::cout << "Based on: " << limitingFactor << std::endl;
    
    // Return information to caller and update timeStepSize
    timeStepSize = finalTimeStep;
    
    // Calculate and store initial energy for future reference
    initialEnergy = calculateTotalEnergy();
    
    // Estimate computational requirements
    long estimatedSteps = static_cast<long>(tFinal / timeStepSize);
    std::cout << "\nEstimated number of time steps: " << estimatedSteps << std::endl;
    
    // Provide warnings if the computation might be too intensive
    if (estimatedSteps > 1000000) {
        std::cout << "WARNING: This simulation will require a very large number of steps." << std::endl;
        std::cout << "Consider using a larger time step or shorter simulation time." << std::endl;
    }
    
    if (tPlotDelta > 0) {
        int plotSteps = int(tFinal / tPlotDelta);
        std::cout << "Will generate approximately " << plotSteps << " snapshots" << std::endl;
        
        // Warn about excessive file output
        if (plotSteps > 1000) {
            std::cout << "WARNING: Large number of output files will be generated." << std::endl;
            std::cout << "Consider increasing tPlotDelta." << std::endl;
        }
    }
    
    // Estimate memory usage (rough approximation)
    double memoryPerBody = 6 * sizeof(double) + sizeof(double*) * 2;  // positions, velocities, mass
    double totalMemoryMB = (NumberOfBodies * memoryPerBody) / (1024 * 1024);
    std::cout << "Estimated memory usage: " << totalMemoryMB << " MB" << std::endl;
}
}